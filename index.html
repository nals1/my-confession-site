<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Confessions — private link</title>
  <meta name="description" content="Create a private message link to share with your crush or friend. No sign in required.">
  <style>
    :root{
      --bg:#fffafc;
      --card:#ffffff;
      --accent:#ff6b9a;
      --accent-2:#7cc6ff;
      --muted:#65707a;
      --text:#0b1220;
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#fff,#fffafc);color:var(--text)}
    .wrap{max-width:980px;margin:2rem auto;padding:1rem}
    .card{background:var(--card);border-radius:14px;padding:1.1rem;box-shadow:0 10px 30px rgba(11,18,32,0.06);border:1px solid rgba(11,18,32,0.03)}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem}
    h1{margin:0;font-size:1.2rem;display:flex;gap:.6rem;align-items:center}
    .logo{width:46px;height:46px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:18px}
    .muted{color:var(--muted);font-size:.95rem}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:1rem}
    label{display:block;font-weight:700;margin-bottom:.25rem}
    input[type=text], textarea{width:100%;padding:.6rem;border-radius:10px;border:1px solid #e6eef8;font-size:1rem}
    textarea{min-height:120px;resize:vertical}
    .controls{display:flex;gap:.5rem;flex-wrap:wrap;margin-top:.6rem}
    .btn{background:#fff;border:1px solid rgba(11,18,32,0.06);padding:.5rem .8rem;border-radius:10px;cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:white;border:none}
    .linkbox{background:#f9fafb;padding:.6rem;border-radius:8px;margin-top:.6rem;font-size:.92rem;word-break:break-all}
    .msg{white-space:pre-wrap;padding:.6rem;border-radius:10px;background:#fff7fb;border:1px solid rgba(255,107,154,0.08)}
    .tiny{font-size:.9rem;color:var(--muted)}
    footer{margin-top:1rem;text-align:center;color:var(--muted);font-size:.9rem}
    .note{margin-top:.5rem;color:var(--muted);font-size:.9rem}
    @media (max-width:900px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1><span class="logo">♡</span> Confessions</h1>
        <div class="tiny">No accounts • Private links • View without signing in</div>
      </header>

      <div class="grid">
        <main>
          <section id="composer" style="padding:.8rem;border-radius:10px;background:linear-gradient(180deg,#fff,#fffafc)">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:800">Create a private message</div>
              <div class="tiny">The generated link contains everything needed to view the message — keep it secret.</div>
            </div>

            <div style="margin-top:.7rem">
              <label for="recipient">Recipient (e.g. "Name of your crush")</label>
              <input id="recipient" type="text" placeholder="Ex: Name (Crush)" />
            </div>

            <div style="margin-top:.6rem">
              <label for="message">Message</label>
              <textarea id="message" placeholder="Write something sweet..."></textarea>
            </div>

            <div style="margin-top:.6rem">
              <input id="encrypt" type="checkbox" checked /> <label for="encrypt" class="tiny">Encrypt message (recommended). The decryption key is embedded in the link fragment and never sent anywhere.</label>
            </div>

            <div class="controls">
              <button id="btn-create" class="btn primary">Create & copy link</button>
              <button id="btn-open" class="btn">Create & open</button>
              <button id="btn-share" class="btn">Share (native)</button>
              <div style="flex:1"></div>
            </div>

            <div id="linkbox" class="linkbox" style="display:none"></div>
            <div class="note">Tip: For maximum privacy, when the link contains an encryption key use the whole URL (including the part after #). Do not post it publicly.</div>
          </section>

          <section id="viewer" style="display:none;margin-top:.9rem;padding:.8rem;border-radius:10px;background:linear-gradient(180deg,#fff,#fffafc)">
            <div style="font-weight:800">Message preview</div>
            <div style="margin-top:.6rem" id="previewRecipient" class="tiny"></div>
            <div id="previewMessage" class="msg" style="margin-top:.5rem">...</div>
            <div class="tiny note" style="margin-top:.5rem">This view was opened from a private link. No sign in required.</div>
          </section>
        </main>

        <aside>
          <div style="padding:.9rem;border-radius:10px;background:linear-gradient(180deg,#fff,#fffafc)">
            <div style="font-weight:700">How this works</div>
            <ul class="tiny" style="padding-left:1rem">
              <li>By default messages are encrypted client-side and the ciphertext + key are included in the link fragment (after #). The server/host never sees the key.</li>
              <li>Only people with the full link can view the message: the person who created it and whoever they share it with.</li>
              <li>No sign-ins required — simple and private. Keep links secret.</li>
            </ul>
            <div class="tiny" style="margin-top:.6rem">Limits: URLs have length limits (keep messages reasonably short). If you need longer messages or editable messages, we can add a small backend later.</div>
          </div>
        </aside>
      </div>

      <footer>
        <small class="muted">Built with ♥ — privacy-first, no accounts.</small>
      </footer>
    </div>
  </div>

  <script>
    // Utilities: base64url encode/decode
    function b64UrlEncode(bytes) {
      return btoa(String.fromCharCode(...new Uint8Array(bytes))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function b64UrlDecodeToUint8(s) {
      s = s.replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const bytes = new Uint8Array(bin.length);
      for (let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    // AES-GCM helpers
    async function generateAesRaw() {
      const key = await crypto.subtle.generateKey({name:'AES-GCM', length:256}, true, ['encrypt','decrypt']);
      const raw = await crypto.subtle.exportKey('raw', key);
      return new Uint8Array(raw);
    }
    async function importAesRaw(rawBytes) {
      return crypto.subtle.importKey('raw', rawBytes.buffer, 'AES-GCM', false, ['encrypt','decrypt']);
    }
    async function encryptRaw(rawKey, plainText) {
      const key = await importAesRaw(rawKey);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(plainText);
      const ciphertext = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, encoded);
      return { iv: new Uint8Array(iv), ciphertext: new Uint8Array(ciphertext) };
    }
    async function decryptRaw(rawKey, ivBytes, ctBytes) {
      const key = await importAesRaw(rawKey);
      const plainBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv: ivBytes}, key, ctBytes);
      return new TextDecoder().decode(plainBuf);
    }

    // token generator (URL-safe)
    function makeToken(len = 30) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return b64UrlEncode(arr).slice(0, len);
    }

    // UI refs
    const recipientEl = document.getElementById('recipient');
    const messageEl = document.getElementById('message');
    const encryptEl = document.getElementById('encrypt');
    const btnCreate = document.getElementById('btn-create');
    const btnOpen = document.getElementById('btn-open');
    const btnShare = document.getElementById('btn-share');
    const linkbox = document.getElementById('linkbox');
    const viewer = document.getElementById('viewer');
    const previewRecipient = document.getElementById('previewRecipient');
    const previewMessage = document.getElementById('previewMessage');

    // Build a private link that contains everything in the fragment.
    // Format: https://.../ (always fragment-only: after #)
    // Fragment params: m=<payloadB64> [&k=<keyB64>] where payload is JSON (recipient, iv, ct OR plaintext)
    async function createPrivateLink(openAfter=false, shareAfter=false) {
      const recipient = recipientEl.value.trim();
      const message = messageEl.value.trim();
      const encrypt = encryptEl.checked;

      if (!recipient) { alert("Please enter the recipient's name (e.g. 'Jamie')"); return; }
      if (!message) { alert('Please write a message'); return; }

      try {
        const base = location.origin + location.pathname;
        if (encrypt) {
          const rawKey = await generateAesRaw();
          const enc = await encryptRaw(rawKey, message);
          const payload = {
            v:1,
            r: recipient,
            iv: b64UrlEncode(enc.iv),
            ct: b64UrlEncode(enc.ciphertext),
            enc: true
          };
          const payloadB64 = b64UrlEncode(new TextEncoder().encode(JSON.stringify(payload)));
          const keyB64 = b64UrlEncode(rawKey);
          const fragment = `m=${payloadB64}&k=${keyB64}`;
          const full = base + '#' + fragment;
          showLink(full, openAfter, shareAfter);
        } else {
          const payload = {
            v:1,
            r: recipient,
            msg: message,
            enc: false
          };
          const payloadB64 = b64UrlEncode(new TextEncoder().encode(JSON.stringify(payload)));
          const fragment = `m=${payloadB64}`;
          const full = base + '#' + fragment;
          showLink(full, openAfter, shareAfter);
        }
      } catch (e) {
        alert('Failed to create link: ' + e.message);
      }
    }

    function showLink(url, openAfter=false, shareAfter=false) {
      linkbox.style.display = 'block';
      linkbox.textContent = url;
      try { navigator.clipboard.writeText(url); } catch (_) {}
      if (openAfter) window.open(url, '_blank');
      if (shareAfter && navigator.share) navigator.share({title:'A private message for you', url}).catch(()=>{});
      alert('Link created (copied if allowed). Share it only with the intended person.');
    }

    btnCreate.addEventListener('click', ()=> createPrivateLink(false,false));
    btnOpen.addEventListener('click', ()=> createPrivateLink(true,false));
    btnShare.addEventListener('click', ()=> createPrivateLink(false,true));

    // On load: if fragment contains m=..., try to decode and show message
    async function tryShowFromFragment() {
      const hash = location.hash.replace(/^#/,'');
      if (!hash) return;
      const params = new URLSearchParams(hash);
      const m = params.get('m');
      if (!m) return;
      // decode payload
      try {
        const payloadBytes = b64UrlDecodeToUint8(m);
        const payloadJson = new TextDecoder().decode(payloadBytes);
        const payload = JSON.parse(payloadJson);
        const recipient = payload.r || '(recipient)';
        previewRecipient.textContent = 'For: ' + recipient;

        if (!payload.enc) {
          // plaintext
          previewMessage.textContent = payload.msg || '';
          viewer.style.display = 'block';
          // hide composer to avoid duplication and confusion
          document.getElementById('composer').style.display = 'none';
          return;
        }

        // encrypted: need k param (the key) in the fragment
        const k = params.get('k');
        if (!k) {
          previewMessage.innerHTML = '<div class="tiny">This message is encrypted. The link does not include the decryption key.</div><div class="tiny">Ask the sender for the full link (it must include the part after # with k=...).</div>';
          previewMessage.style.whiteSpace = 'normal';
          viewer.style.display = 'block';
          document.getElementById('composer').style.display = 'none';
          return;
        }

        const rawKey = b64UrlDecodeToUint8(k);
        const iv = b64UrlDecodeToUint8(payload.iv);
        const ct = b64UrlDecodeToUint8(payload.ct);
        try {
          const plain = await decryptRaw(rawKey, iv, ct);
          previewMessage.textContent = plain;
        } catch (e) {
          previewMessage.textContent = 'Failed to decrypt message. The key may be incorrect.';
        }
        viewer.style.display = 'block';
        document.getElementById('composer').style.display = 'none';
      } catch (e) {
        console.error('Failed to decode message payload:', e);
      }
    }

    // Initialize display if there's a fragment
    window.addEventListener('load', tryShowFromFragment);

    // Small UX: warn if message is too long for typical URL lengths
    messageEl.addEventListener('input', () => {
      const len = messageEl.value.length;
      const note = document.querySelector('.note');
      if (len > 1500) {
        note.textContent = 'Long message — very long links may not work in all browsers/services. Consider sending shorter messages.';
      } else {
        note.textContent = 'Tip: For maximum privacy, when the link contains an encryption key use the whole URL (including the part after #). Do not post it publicly.';
      }
    });
  </script>
</body>
</html>
